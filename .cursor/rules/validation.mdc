---
description: Runtime type validation with TypeBox schemas and JSDoc for IDE support
globs: ["src/**/*.js"]
---

# Runtime Validation Standards

## Type Safety Philosophy
- **Compile-time safety**: JSDoc comments in .js files + TypeScript type checking with `npm run type-check`
- **Runtime validation**: TypeBox schemas provide actual runtime type checking
- **Zero transpilation**: Pure JavaScript with immediate browser execution
- **IDE support**: JSDoc comments in .js files provide full TypeScript IntelliSense and type hints
- **Lightweight**: TypeBox is ~50kb and tree-shakeable, TypeScript is dev-only

## Tree-Shakeable Import Requirements

All external library imports MUST use tree-shakeable patterns to minimize bundle size:

```javascript
// ✅ CORRECT: Specific imports (tree-shakeable)
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';
import { debounce } from 'lodash-es';
import { format } from 'date-fns';

// ❌ WRONG: Entire library imports (massive bundle size)
import * as TypeBox from '@sinclair/typebox';     // ~50KB+ 
import _ from 'lodash';                           // ~70KB+
import dateFns from 'date-fns';                  // ~200KB+
```

## JSDoc + TypeScript Type Checking + TypeBox Pattern
```javascript
// src/types/transaction.js
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

/**
 * @typedef {Object} Transaction
 * @property {string} id - Unique transaction identifier (UUID format)
 * @property {number} amount - Transaction amount in cents (avoids floating-point errors)
 * @property {'income'|'expense'|'transfer'} type - Transaction category
 * @property {string} description - Human-readable description (1-500 chars)
 * @property {Date} createdAt - When transaction was recorded
 */

/**
 * @typedef {Omit<Transaction, 'id'|'createdAt'>} TransactionInput
 */

// Runtime schema for validation (mirrors TypeScript types)
export const TransactionSchema = Type.Object({
  id: Type.String({ format: 'uuid' }),
  amount: Type.Integer({ minimum: 1 }),
  type: Type.Union([
    Type.Literal('income'),
    Type.Literal('expense'), 
    Type.Literal('transfer')
  ]),
  description: Type.String({ minLength: 1, maxLength: 500 }),
  createdAt: Type.Date()
});

/**
 * Validates a transaction object at runtime.
 * 
 * This function provides runtime type safety to complement TypeScript's
 * compile-time checking. Used at API boundaries and user input validation.
 * 
 * @param {unknown} data - Data to validate (typically from external sources)
 * @returns {Transaction} Validated transaction object
 * @throws {Error} If validation fails with detailed error message
 */
export function validateTransaction(data) {
  if (!Value.Check(TransactionSchema, data)) {
    const errors = [...Value.Errors(TransactionSchema, data)];
    throw new Error(`Invalid transaction: ${errors[0].message}`);
  }
  return /** @type {Transaction} */ (data);
}

/**
 * Creates a new transaction with automatic ID generation and validation.
 * 
 * This function demonstrates the hybrid approach: JSDoc comments provide
 * compile-time type safety via TypeScript checking, while TypeBox provides
 * runtime validation of the complete transaction object.
 * 
 * @param {TransactionInput} input - Transaction input data
 * @returns {Transaction} Created and validated transaction
 */
export function createTransaction(input) {
  // JSDoc + TypeScript checking ensures input has correct shape at compile time
  const transaction = {
    ...input,
    id: crypto.randomUUID(),
    createdAt: new Date()
  };
  
  // TypeBox ensures complete object is valid at runtime
  return validateTransaction(transaction);
}
```

## File Organization
```
src/types/
├── transaction.js      # Transaction schemas and validators
├── user.js           # User schemas and validators  
├── account.js        # Account schemas and validators
└── api.js            # API request/response schemas
```

## Domain Schemas

### User Types
```javascript
// src/types/user.js
import { Type } from '@sinclair/typebox';

/**
 * @typedef {Object} User
 * @property {string} id - User ID
 * @property {string} email - Email address
 * @property {string} name - Full name
 * @property {UserPreferences} preferences - User preferences
 */

export const UserSchema = Type.Object({
  id: Type.String({ format: 'uuid' }),
  email: Type.String({ format: 'email' }),
  name: Type.String({ minLength: 1, maxLength: 100 }),
  preferences: Type.Ref('UserPreferences')
});

/**
 * @typedef {Object} UserPreferences
 * @property {'USD'|'EUR'|'GBP'} currency - Preferred currency
 * @property {'light'|'dark'} theme - UI theme
 * @property {boolean} notifications - Email notifications enabled
 */

export const UserPreferencesSchema = Type.Object({
  currency: Type.Union([
    Type.Literal('USD'),
    Type.Literal('EUR'), 
    Type.Literal('GBP')
  ]),
  theme: Type.Union([Type.Literal('light'), Type.Literal('dark')]),
  notifications: Type.Boolean()
}, { $id: 'UserPreferences' });
```

### API Schemas
```javascript
// src/types/api.js
import { Type } from '@sinclair/typebox';

/**
 * @typedef {Object} ApiResponse
 * @property {boolean} success - Request success status
 * @property {any} [data] - Response data (if successful)
 * @property {string} [error] - Error message (if failed)
 */

export const ApiResponseSchema = Type.Object({
  success: Type.Boolean(),
  data: Type.Optional(Type.Any()),
  error: Type.Optional(Type.String())
});

/**
 * @typedef {Object} PaginatedResponse
 * @property {Array} items - Array of items
 * @property {number} total - Total number of items
 * @property {number} page - Current page
 * @property {number} pageSize - Items per page
 */

export const PaginatedResponseSchema = Type.Object({
  items: Type.Array(Type.Any()),
  total: Type.Integer({ minimum: 0 }),
  page: Type.Integer({ minimum: 1 }),
  pageSize: Type.Integer({ minimum: 1, maximum: 100 })
});
```

## Validation Patterns

### Input Validation
```javascript
// src/lib/validators.js
import { Value } from '@sinclair/typebox/value';

/**
 * Generic validator function
 * @param {import('@sinclair/typebox').TSchema} schema - TypeBox schema
 * @param {unknown} data - Data to validate
 * @returns {any} Validated data
 * @throws {Error} If validation fails
 */
export function validate(schema, data) {
  if (!Value.Check(schema, data)) {
    const errors = [...Value.Errors(schema, data)];
    const message = errors.map(e => `${e.path}: ${e.message}`).join(', ');
    throw new Error(`Validation failed: ${message}`);
  }
  return data;
}

/**
 * Safe validator that returns result object
 * @param {import('@sinclair/typebox').TSchema} schema - TypeBox schema
 * @param {unknown} data - Data to validate
 * @returns {{success: true, data: any} | {success: false, error: string}}
 */
export function safeValidate(schema, data) {
  try {
    const validData = validate(schema, data);
    return { success: true, data: validData };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### Form Validation
```javascript
// Example: Form handling with validation
import { TransactionSchema } from '../types/transaction.js';
import { safeValidate } from '../lib/validators.js';

/**
 * Handles transaction form submission
 * @param {FormData} formData - Form data from submission
 */
export function handleTransactionForm(formData) {
  const input = {
    amount: parseInt(formData.get('amount')),
    type: formData.get('type'),
    description: formData.get('description')
  };
  
  const result = safeValidate(TransactionSchema, input);
  
  if (!result.success) {
    showError(result.error);
    return;
  }
  
  // Process valid transaction
  saveTransaction(result.data);
}
```

## Performance Considerations
- **Lazy loading**: Import schemas only when needed
- **Schema caching**: Cache compiled schemas for repeated use
- **Minimal schemas**: Keep schemas as simple as possible
- **Tree shaking**: Import only the TypeBox functions you need

## IDE Configuration
- **JSDoc Support**: IDE settings configured in .vscode/settings.json for optimal TypeScript/JavaScript IntelliSense
- **Auto Imports**: Automatic import suggestions enabled for better developer experience
- **Type Checking**: JavaScript type checking enabled through JSDoc comments

## Testing Schemas
```javascript
// src/types/__tests__/transaction.test.js
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { validateTransaction, TransactionSchema } from '../transaction.js';
import { Value } from '@sinclair/typebox/value';

describe('Transaction validation', () => {
  it('should validate correct transaction', () => {
    const transaction = {
      id: crypto.randomUUID(),
      amount: 1000,
      type: 'income',
      description: 'Salary',
      createdAt: new Date()
    };
    
    assert.doesNotThrow(() => validateTransaction(transaction));
    assert.strictEqual(Value.Check(TransactionSchema, transaction), true);
  });

  it('should reject invalid transaction', () => {
    const invalidTransaction = {
      amount: -100, // Invalid: negative amount
      type: 'invalid', // Invalid: not a valid type
      description: '' // Invalid: empty description
    };
    
    assert.throws(() => validateTransaction(invalidTransaction));
    assert.strictEqual(Value.Check(TransactionSchema, invalidTransaction), false);
  });
});
```