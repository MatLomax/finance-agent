---
description: Pure business logic functions with TDD methodology and educational documentation
globs: ["src/**/*.js"]
---

# Pure Function Standards

## Function Purity & SOLID
- **Pure functions only**: No side effects, same input always produces same output
- **Single Responsibility**: One function, one purpose
- **Open/Closed**: Functions should be extensible without modification
- **Liskov Substitution**: Functions should be replaceable by subtypes
- **Interface Segregation**: Don't depend on unused parameters
- **Dependency Inversion**: Depend on abstractions, not concretions

## Test-Driven Development (TDD)
1. **Red**: Write a failing test that defines the desired behavior
2. **Green**: Write minimal code to make the test pass
3. **Refactor**: Improve code while keeping tests green

## Testing Framework
- Use **Node.js native test runner** (zero dependencies preferred)
- Test files: `src/lib/__tests__/[function-name].test.js`
- Test both function logic AND schema validation
- 100% test coverage required
- Tests must run in < 50ms total (pure JS is faster) (See MAX_PURE_FUNCTION_TEST_TIME_MS in src/lib/consts.js)

## File Structure
```
src/lib/
├── __tests__/
│   ├── calculate-interest.test.js
│   └── format-currency.test.js
├── validators.js              # Shared validation utilities
├── calculate-interest.js
└── format-currency.js
```

## Documentation Requirements
Each function file must include JSDoc comments for TypeScript type checking + TypeBox validation:

```javascript
// src/lib/calculate-interest.js
import { Type } from '@sinclair/typebox';
import { validate } from './validators.js';

// Input validation schema
const CompoundInterestInputSchema = Type.Object({
  principal: Type.Number({ minimum: 0 }),
  rate: Type.Number({ minimum: 0, maximum: 1 }),
  time: Type.Number({ minimum: 0 }),
  compounding: Type.Integer({ minimum: 1 })
});

/**
 * Calculate compound interest for a given principal amount.
 * 
 * Uses the compound interest formula: A = P(1 + r/n)^(nt)
 * Where: A = final amount, P = principal, r = annual rate, n = compounding frequency, t = time
 * 
 * This function is used in the finance agent to compute investment 
 * growth projections and loan interest calculations.
 * 
 * @param {number} principal - The initial amount (must be positive)
 * @param {number} rate - Annual interest rate (as decimal, 0.05 = 5%)
 * @param {number} time - Time period in years (must be positive)
 * @param {number} compounding - Compounding frequency per year (integer)
 * @returns {number} The final amount after compound interest
 * 
 * @example
 * const result = calculateCompoundInterest(1000, 0.05, 2, 12);
 * // Returns: 1104.89 (approximately)
 * 
 * @throws {Error} If input validation fails
 */
export function calculateCompoundInterest(principal, rate, time, compounding) {
  // Runtime validation
  const input = { principal, rate, time, compounding };
  validate(CompoundInterestInputSchema, input);
  
  // Break down the compound interest formula: A = P(1 + r/n)^(nt)
  
  // Step 1: Calculate the periodic interest rate (annual rate divided by compounding frequency)
  // This gives us the interest rate per compounding period
  const periodicRate = rate / compounding;
  
  // Step 2: Calculate the base growth factor (1 + periodic rate)
  // This represents how much the principal grows each compounding period
  const growthFactor = 1 + periodicRate;
  
  // Step 3: Calculate total number of compounding periods
  // This is how many times interest compounds over the entire time period
  const totalPeriods = compounding * time;
  
  // Step 4: Apply compound growth using exponentiation
  // Each period, the entire amount (not just principal) grows by the growth factor
  const compoundGrowth = Math.pow(growthFactor, totalPeriods);
  
  // Step 5: Apply compound growth to the principal to get final amount
  const finalAmount = principal * compoundGrowth;
  
  return finalAmount;
}
```

## Implementation Rules
- Function name must match filename
- Export as named export (not default)
- Include TypeBox schema for input validation
- External dependencies: TypeBox, lodash-es, date-fns, et. al. where needed - MUST use tree-shakeable imports: `import { Type } from '@sinclair/typebox'`
- Maximum 30 lines of implementation code per function (allowing for detailed comments) (See MAX_IMPLEMENTATION_LINES_PER_FUNCTION in src/lib/consts.js)
- Pure JavaScript ES2022+ - no polyfills, no transpilation
- Runtime validation on all inputs

## Code Comment Standards
- **Follow comments.mdc**: All commenting standards are defined in the dedicated comments.mdc file
- **Mathematical Functions**: Must include formula documentation and step-by-step breakdowns
- **Financial Context**: Explain how calculations relate to real-world finance concepts
- **Educational Value**: Code should teach finance concepts to readers